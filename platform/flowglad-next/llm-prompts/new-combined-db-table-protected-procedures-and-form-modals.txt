All of the following changes will happen in the directory `./packages/flowglad-next`, so when you see a path like `./src/db/schema/unicornRiders.ts`, it should be translated to `./packages/flowglad-next/src/db/schema/unicornRiders.ts`.

# 1. Create an ORM Schema
You're creating a new ORM schema for a Postgres database table, as well as all the associated types, queries and mutations.

You will rely heavily on the exported methods at ./src/db/tableUtils.ts to write your code.

Here's what you need to do, assuming the table is named "UnicornRiders" (the actual name will be provided to you by the prompt - "UnicornRiders" is just an example):
- Create a new file in the `./src/db/schema/unicornRiders.ts` directory. The file name should be the name of the table, in camelCase.
  - Use the `./src/db/schema/flows.ts` file as a reference pattern.
  - The name of the table should be declared as a global string constant, in PascalCase, (`const TABLE_NAME = 'UnicornRiders'`). And it should be used in the schema declaration as well as any constructor method invoked in the file where a table name is required.
  - All foreign keys referencing other tables must be PascalCase. Their types should match the column that they reference, of course.
  - All ORM schema declarations should use tableBase from tableUtils.
  - If the schema requires a new enum, declare and export that enum in src/types.ts, and then use that enum in the schema via pgEnumColumn.
  - Add pgPolicy to the schema to enable row level security. By default, the policy should be "permissive", and the "to" should be "authenticated". The "for" should be "all". And the policy can be:
  ```ts
  using: sql`"OrganizationId" in (select "OrganizationId" from "Memberships") // if there is a foreign key to a table that has an OrganizationId, you can use that instead
  ```
  - Here's a quick example of what the start of the file should look like, roughly:
  ```ts
  import { boolean, text, pgTable, pgPolicy } from 'drizzle-orm/pg-core'
  import { z } from 'zod'
  import {
    tableBase,
    notNullStringForeignKey,
    constructIndex,
    newConstructUniquenessIndex,
    enhancedCreateInsertSchema,
  } from '@/db/tableUtils'
  import { organizations } from '@/db/schema/organizations'
  import { createSelectSchema } from 'drizzle-zod'
  import { UnicornRiderStatus } from '@/types'

  const TABLE_NAME = 'UnicornRiders'

  export const unicornRiders = pgTable(
    TABLE_NAME,
    {
      ...tableBase('unicornRider'),
      OrganizationId: notNullStringForeignKey(
        'OrganizationId',
        organizations
      ),
      superSecretColumn: text('superSecretColumn').notNull(),
      title: text('title').notNull(),
      active: boolean('active').notNull().default(true),
      status: pgEnumColumn({
        enumName: 'UnicornRiderStatus',
        columnName: 'status',
        enumBase: UnicornRiderStatus,
      }), // use the $type method to declare the type of enum columns so we're not dealing with string inferred types
      email: text('email').notNull().unique(),
    },
    (table) => {
      return [
        constructIndex(TABLE_NAME, [table.OrganizationId]),
        constructIndex(TABLE_NAME, [table.status]),
        newConstructUniquenessIndex(TABLE_NAME, [table.email]),
        pgPolicy('Enable read for own organizations', {
          as: 'permissive',
          to: 'authenticated',
          for: 'all',
          using: sql`"OrganizationId" in (select "OrganizationId" from "Memberships")`,
        }),
      ]
    }
  ).enableRLS()
  ```
  - If there are any foreign keys, use the (notNullish|nullable)(String|Integer)ForeignKey methods in tableUtils to declare them.
    - Table Indexes: these are declared via the second argument in pgTable which is a function that takes the table and returns an object with indexes.
      - If there are any foreign keys, make sure to make database indexes of them. Use constructIndex from tableUtils.
      - If there are any unique constraints, make database indexes of them. Use constructUniquenessIndex from tableUtils.
      - If there are any enum columns, make database indexes of them
  - Export Zod Schema and types for: Insert, Select, Update, and Mutation Inputs
    - Delcare a columnRefinments object that has all of the zod schemas for each column that needs to be refined
    - You will need to make the following zod schema for each table. In the case that each table has unique subtypes (e.g. subscription variants and one-time variants), you will need to declare the subtypes accordingly:
      - columnRefinements (not a schema, but an object that contains the zod schema for each column that needs to be refined, to be used when creating the schema below)
      - insert schema
      - select schema
      - update schema
      - mutation input schema
      - client select schema
      - client insert schema
      - client update schema
      - XInsert
      - XUpdate
      - XRecord (the name for select returns)
      - XClientInsert
      - XClientUpdate
      - XClientRecord
    - Export unicornRidersInsertSchema and unicornRidersSelectSchema in the file, constructed via `createSelectSchema` from drizzle-zod and `enhancedCreateInsertSchema` from tableUtils.
    - Also export the update, as well as the createUnicornRiderInputSchema and editUnicornRiderInputSchema schemas:
      ```ts
      import { createSelectSchema } from 'drizzle-zod'
      import { enhancedCreateInsertSchema } from '@/db/tableUtils' // merge this with other imports from the same file
      import core from '@/utils/core'
      // rest of the file...

      // declare a columnRefinements object that contains the zod schema for each column that needs to be refined.
      // the following column types should be refined:
      // - enums: use core.createSafeZodEnum
      // - positive integers: use core.safeZodPositiveInteger
      // - dates: use core.safeZodDate
      // All nullable columns should also have a .nullable() method applied to their schema in the refinements object.
      const columnRefinements = {
        status: core.createSafeZodEnum(UnicornRiderStatus),
      }
      /*
       * database schema
       */
      export const unicornRidersInsertSchema =
        enhancedCreateInsertSchema(unicornRiders, columnRefinements)

      export const unicornRidersSelectSchema =
        createSelectSchema(unicornRiders).extend(columnRefinements)

      export const unicornRidersUpdateSchema = unicornRidersSelectSchema.partial().extend({
        id: core.safeZodPositiveInteger
      })

      const createOnlyColumns = {
        email: true,
      }
      const readOnlyColumns = {
        livemode: true,
        OrganizationId: true,
      } as const

      const hiddenColumns = {
        superSecretColumn: true,
      } as const

      const hiddenColumns = {
        superSecretColumn: true,
      } as const
      
      const nonClientEditableColumns = {
        ...hiddenColumns,
        ...readOnlyColumns,
      } as const

      /*
       * client schemas
       */
      export const unicornRiderClientInsertSchema =
        unicornRidersInsertSchema.omit(nonClientEditableColumns)

      export const unicornRiderClientUpdateSchema =
        unicornRidersUpdateSchema.omit({...nonClientEditableColumns, ...createOnlyColumns})

      export const unicornRiderClientSelectSchema =
        unicornRidersSelectSchema.omit(hiddenColumns)

      export namespace UnicornRider {
        export type Insert = z.infer<typeof unicornRiderInsertSchema>
        export type Update = z.infer<typeof unicornRiderUpdateSchema>
        export type Record = z.infer<typeof unicornRiderSelectSchema>
        export type ClientInsert = z.infer<typeof unicornRiderClientInsertSchema>
        export type ClientUpdate = z.infer<typeof unicornRiderClientUpdateSchema>
        export type ClientRecord = z.infer<typeof unicornRiderClientSelectSchema>
      }

      export const createUnicornRiderInputSchema = z.object({
        unicornRider: unicornRiderClientInsertSchema
      })

      export type CreateUnicornRiderInput = z.infer<typeof createUnicornRiderInputSchema>
      
      export const editUnicornRiderInputSchema = z.object({
        unicornRider: unicornRiderClientUpdateSchema
      })
      export type EditUnicornRiderInput = z.infer<typeof editUnicornRiderInputSchema>
      // file continues...
      ```
    - The refine key for every integer column should be safeZodPositiveInteger, so that we can correctly parse inputs received as forms from the client
  - Export the following types (import { IdNumberParam } from '@/types'):
    - UnicornRiderInsert: z.infer<typeof unicornRidersInsertSchema>
    - UnicornRiderUpdate: z.infer<typeof unicornRidersUpdateSchema>
    - UnicornRiderRecord: z.infer<typeof unicornRidersSelectSchema>
- Create a new file at `./src/db/tableMethods/unicornRiderMethods.ts`. The file name should be the name of the table, in camelCase.
  - The file should export, at a minimum, the following functions:
    ```typescript
    import {
      createSelectById,
      createInsertFunction,
      createUpdateFunction,
      createSelectFunction,
      ORMMethodCreatorConfig,
    } from '@/db/tableUtils'
    import {
      unicornRiders,
      unicornRidersInsertSchema,
      unicornRidersSelectSchema,
      unicornRidersUpdateSchema,
    } from '@/db/schema/unicornRiders'

    const config: ORMMethodCreatorConfig<
      typeof unicornRiders,
      typeof unicornRidersSelectSchema,
      typeof unicornRidersInsertSchema,
      typeof unicornRidersUpdateSchema
    > = {
      selectSchema: unicornRidersSelectSchema,
      insertSchema: unicornRidersInsertSchema,
      updateSchema: unicornRidersUpdateSchema,
    }

    export const selectUnicornRiderById = createSelectById(
      unicornRiders,
      config
    )

    export const insertUnicornRider = createInsertFunction(
      unicornRiders,
      config
    )

    export const updateUnicornRider = createUpdateFunction(
      unicornRiders,
      config
    )

    export const selectUnicornRiders = createSelectFunction(
      unicornRiders,
      config
    )
    ```
    - upsertUnicornRidersBy(.*) (where (.*) is the name of each uniqueness constraint, e.g. `upsertUnicornRiderByEmail`. For multi-column constraints, use "And" between column names, e.g. `upsertUnicornRiderByEmailAndPassword`, etc.). Below are examples of upserts on multiple and single column uniquness constraints respecitvely:
    ```typescript
    const upsertUnicornRiderByEmailAndPassword = createUpsertFunction(
      unicornRiders,
      [unicornRiders.email, unicornRiders.password],
      config
    )

    const upsertUnicornRiderById = createUpsertFunction(
      unicornRiders,
      unicornRiders.id,
      config
    )
    ```

# 2. Create new TRPC protectedProcedures for create and edit

Follow the following instructions for both the createUnicornRider and editUnicornRider protectedProcedures.
You are creating a new trpc protectedProcedure that will be a mutation. Refer to the TRPC docs for more information.

You can rely on the other protectedProcedures the directory @/server/mutations as reference patterns. Here is how it will look for example, for a mutation called editCustomerProfile:

```ts
// in @/server/mutations/editCustomerProfile.ts
import { protectedProcedure } from '@/server/trpc'
import { authenticatedTransaction } from '@/db/databaseMethods'
import { editCustomerProfileSchema } from '@/db/schema/customerProfiles'
import { updateCustomerProfile } from '@/db/tableMethods/customerProfileMethods'

export const editCustomerProfile = protectedProcedure
  .input(editCustomerProfileSchema)
  .mutation(async ({ input }) => {
    const updatedCustomerProfile = await authenticatedTransaction(
      async ({ transaction }) => {
        return updateCustomerProfile(input.customerProfile, transaction)
      }
    )
    return {
      data: { customerProfile: updatedCustomerProfile },
    }
  })
```

And then in @/server/index.ts, you would add it to the appRouter like so:

```ts
// ... existing imports
import { editCustomerProfile } from './mutations/editCustomerProfile'

export const appRouter = router({
  // ... existing mutation
  editCustomerProfile,
})

## Notes

- Import the necessary zod schema from the files in "@/db/schema/*"

- You should only need one zod schema. If it's not found, you should create one in the @/db/schema/<tableName.ts> file, and export it. The shape of the schema should be like so: { customerProfile: customerProfilesUpdateSchema }

- The name of the mutation will specified in the prompt. Here's how the naming of the mutation relates to the ORM methods you would use:
    - editCustomerProfile => updateCustomerProfile
    - createCustomerProfile => insertCustomerProfile
    - deleteCustomerProfile => deleteCustomerProfile
We use "edit" instead of "update" to make it clear that this update may have side effects

- If you do need to make a new zod schema, adhere to the following guidelines:
  - Don't make a new zod object with individual properties. What you need should be available in the @/db/schema/<tableName.ts> file.
  - Name the schema like so: <edit|create|delete><TableName>Schema
  - Export both the schema and the inferred type from the db/schema/<tableName.ts> file:
  ```ts
  export const editCustomerProfileSchema = z.object({
    customerProfile: customerProfilesUpdateSchema
  })
  export type EditCustomerProfileInput = z.infer<typeof editCustomerProfileSchema>
  ```

# 3. Create Form Modals
- In @/app/components/forms, create a new file UnicornRiderFormFields.tsx, and stub it out like so:
```tsx
'use client'

import { useFormContext } from 'react-hook-form'
import { CreateUnicornRiderInput } from '@/db/schema/unicornRiders'

export default function UnicornRiderFormFields() {
  const form = useFormContext<CreateUnicornRiderInput>()
  return <div>UnicornRiderFormFields</div>
}
```

Using '@/app/components/forms/FormModal', create new form modals for the newly created table:
- @/app/components/components/CreateUnicornRiderModal
- @/app/components/components/EditUnicornRiderModal

They should follow the following pattern:
```ts
// in @/app/components/forms/EditUnicornRiderModal.tsx
'use client'

import FormModal from '@/app/components/forms/FormModal'
import {
  UnicornRiderRecord,
  editUnicornRiderSchema,
} from '@/db/schema/unicornRiders'
import { UnicornRiderFormFields } from '@/app/components/forms/UnicornRiderFormFields'
import { trpc } from '@/app/_trpc/client'

interface EditUnicornRiderModalProps {
  isOpen: boolean
  setIsOpen: (isOpen: boolean) => void
  // omit for CreateUnicornRiderModal
  unicornRider: UnicornRiderRecord
}

const EditUnicornRiderModal: React.FC<EditUnicornRiderModalProps> = ({
  isOpen,
  setIsOpen,
  unicornRider,
}) => {
  const editUnicornRider = trpc.editUnicornRider.useMutation()
  return (
    <FormModal
      isOpen={isOpen}
      setIsOpen={setIsOpen}
      title="Edit Unicorn Rider"
      formSchema={editUnicornRiderSchema}
      defaultValues={{ unicornRider }}
      onSubmit={editUnicornRider.mutateAsync}
    >
      <UnicornRiderFormFields />
    </FormModal>
  )
}

export default EditUnicornRiderModal
```
